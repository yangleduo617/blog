#    算法

## 时间复杂度

### 时间频度

一个算法中的语句执行次数称为语句频度或时间频度，记为T(N)。

### 时间复杂度定义

一般情况下，算法中的基本操作语句执行次数是问题规模N的某个函数，T(N)。

去掉常数项、低次项、最高阶项系数，剩下的f(N)，表示为O(f(N))，即时间复杂度。

### 常见的时间复杂度

**从上往下时间复杂度依次增加**

常数阶	O(1)：只要没有循环等复杂结构

对数阶	O(logN)：log~2~N，例如循环中有 i = i * 2，二分法

线性阶	O(N)：一个正常的for循环

线性对数阶	O(NlogN)：将时间复杂度为O(logN)的代码循环N遍

平方阶	O(N^2^)：双层循环

立方阶	O(N^3^)：三层循环

k次方阶	O(N^k^)：k层循环

指数阶	O(2^N^)

阶乘阶	O(N!)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220122133422341.png)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/排序算法.png)

### 空间复杂度

该算法耗费的存储空间，也是问题规模N的函数。

一些缓存产品（redis、memcache）和算法（基数排序）本质就 是用空间换时间。

## 排序算法

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/sort.png)

### 冒泡排序

```java
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length == 1) {
        return;
    }
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }
}

public static void swap(int[] arr, int i, int j) {
    int temp;
    temp = arr[j];
    arr[j] = arr[i];
    arr[i] = temp;
}
```



### 快速排序

例如：[-9, 78, 0, 23, -567, 70]

思路分析：

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/quicksort.png)

```java
 public static void quickSort(int[] arr, int begin, int end) {
        if (begin > end) {
            return;
        }
        int l = begin, r = end;
        int base = arr[begin], temp;
        while (l != r) {
            // 从右向左寻找小于基准数的值
            while (arr[r] >= base && l < r) {
                r--;
            }
            while (arr[l] <= base && l < r) {
                l++;
            }
            if (l < r) {
                temp = arr[l];
                arr[l] = arr[r];
                arr[r] = temp;
            }
        }
        // 基准数归位
        arr[begin] = arr[l];
        arr[l] = base;
        // 递归将左右两边的数进行排序
        quickSort(arr, begin, l - 1);
        quickSort(arr, l + 1, end);
    }
```

### 三路随机快排

```java
class PartitionQuickSort {
    public void quickSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    public void quickSort(int[] arr, int l, int r) {
        if (l >= r) {
            return;
        }
        // 最右边的一个作为基准
        swap(arr, (int) Math.random() * (r - l + 1) + l, r);
        // [l ... less] [less + 1 ... more] [more + 1 ... r]
        // 分别是小于、等于、大于部分
        int less = l - 1;
        int more = r;
        // 当前数的位置
        int temp = l;
        while (temp < more) {
            if (arr[temp] < arr[r]) {
                swap(arr, ++less, temp++);
            } else if (arr[temp] > arr[r]) {
                swap(arr, --more, temp);
            } else {
                temp++;
            }
        }
        swap(arr, more, r);
        quickSort(arr, l, less);
        quickSort(arr, more + 1, r);
    }
    
    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] =temp;
    }
}
```

### 选择排序

第 i 次迭代，将每次迭代的最小值放在 i 位置上。

```java
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for(int i = 0; i < arr.length - 1; i++) {
        int index = i;
        for (int j = i + 1; j < arr.length; j++) {
            // 将小的值交换
            if (arr[index] > arr[j]) {
                index = j;
            }
            // index = arr[j] < arr[index] ? j : index; 
        }
        swap(arr, i, index);
    }
}
public static void swap(int[] arr, int i, int j) {
	int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### 插入排序

每次迭代保证 0 ~ i 位置上有序

```java
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int temp;
    for (int i = 0; i < arr.length; i++) {
        // 0 ~ i 位置上有序
        for (int j = i - 1; j >=0 && arr[j] > arr[j + 1]; j--) {
            temp = arr[j]; 
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```

### 归并排序

简单的递归，左边排好序，右边排好序，再让整体有序。

```java
public static void mergeSort(int[] arr) {
    if (arr.length < 2 || arr == null) {
        return;
    }
    process(arr, 0, arr.length - 1);
}

private static void process(int[] arr, int l, int r) {
    if (l == r) {
        return;
    }
    int mid = l + ((r - l) >> 1);
    process(arr, l, mid);
    process(arr, mid + 1,r);
    merge(arr, l, mid, r);
}

private static void merge(int[] arr, int l, int mid, int r) {
    int[] temp = new int[r - l + 1];
    // 供 temp 填数用
    int k = 0;
    int i = l, j = mid + 1;
    // 两个指针没有越界的情况
    while (i <= mid && j <= r) {
        // 比较两个左面的数，谁小拷贝出来
        temp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];
    }
    // 复制左边数组剩余的值
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    // 复制右边数组剩余的值
    while (j <= r) {
        temp[k++] = arr[j++];
    }
    // 将排好顺序的数组复制回去
    for (i = 0; i < temp.length; i++) {
        arr[l + i] = temp[i];
    }
}
```

### 堆排序

```java
	public static void heapSort(int[] arr) {
        if (arr.length < 2 || arr == null) {
            return;
        }
        // 将数组变成大根堆
//        for (int i = arr.length - 1; i >= 0; i--) {
//            heapify(arr, i, arr.length);
//        }
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }

        int heapSize = arr.length;
        // 最后的位置与堆第一交换，将堆的大小减一
        swap(arr, 0, --heapSize);
        while (heapSize > 0) {
            heapify(arr, 0, heapSize);
            swap(arr, 0, --heapSize);
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * arr[index] 位置的数能否向下移动
     * @param arr
     * @param index
     * @param heapSize
     */
    private static void heapify(int[] arr, int index, int heapSize) {
        // 左孩子的下标
        int left = 2 * index + 1;
        while (left < heapSize) {
            // 左右孩子进行比较，将较大的孩子的下标赋给 largest
            int largest = (left + 1 < heapSize) && (arr[left + 1] > arr[left]) ? (left + 1) : left;
            largest = arr[index] > arr[largest] ? index : largest;
            // 最大的是当前结点
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = 2 * index + 1;
        }
    }

    /**
     * arr[index] 刚来的数，往上变成大根堆
     * @param arr
     * @param index
     */
    private static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }
```

### 基数排序

```java
// only for no-negative value
public static void radixSort(int[] arr) {
	if (arr == null || arr.length < 2) {
		return;
	}
	radixSort(arr, 0, arr.length - 1, maxbits(arr));
}

public static int maxbits(int[] arr) {
	int max = Integer.MIN_VALUE;
	for (int i = 0; i < arr.length; i++) {
		max = Math.max(max, arr[i]);
	}
	int res = 0;
	while (max != 0) {
		res++;
		max /= 10;
	}
	return res;
}

// arr[L..R]排序  ,  最大值的十进制位数digit
public static void radixSort(int[] arr, int L, int R, int digit) {
	final int radix = 10;
	int i = 0, j = 0;
	// 有多少个数准备多少个辅助空间
	int[] help = new int[R - L + 1];
	for (int d = 1; d <= digit; d++) { // 有多少位就进出几次
		// 10个空间
	    // count[0] 当前位(d位)是0的数字有多少个
		// count[1] 当前位(d位)是(0和1)的数字有多少个
		// count[2] 当前位(d位)是(0、1和2)的数字有多少个
		// count[i] 当前位(d位)是(0~i)的数字有多少个
		// 可以进行按位的分片
		int[] count = new int[radix]; // count[0..9]
		for (i = L; i <= R; i++) {
			// 103  1   3
			// 209  1   9
			j = getDigit(arr[i], d);
			// 记录当前位上的数出现了多少次
			count[j]++;
		}
		for (i = 1; i < radix; i++) {
			// 前缀和
			count[i] = count[i] + count[i - 1];
		}
		// 后进后出队列（bucket）
		for (i = R; i >= L; i--) {
			// 拿到 d 位上的数放入辅助数组 help 中进行分组
			j = getDigit(arr[i], d);
			help[count[j] - 1] = arr[i];
			count[j]--;
		}
		for (i = L, j = 0; i <= R; i++, j++) {
			// 将辅助数组中的元素复制回原数组，相当于出桶
			arr[i] = help[j];
		}
	}
}

/**
 * @Author   yyw
 * @DateTime 2021-11-24T16:47:50+0800
 * @param    x                        [description]
 * @param    d                        [description]
 * @return                            将处于 d 位置上的数取出来
 */
public static int getDigit(int x, int d) {
	return ((x / ((int) Math.pow(10, d - 1))) % 10);
}
```

## 查找算法

### 顺序（线性）查找

数组无序，有序均可

### 二分查找

对从小到大的有序数组进行二分查找，思路分析：

1. 确定该数组的中间的下标 mid = (left + right) / 2

2. 然后将要查找的数findVal和arr[mid]比较，若

   2.1 findVal > arr[mid] 要查找的数在mid右边，因此需要递归向右查找

   2.2 findVal < arr[mid] 要查找的数在mid左边，因此需要递归向左查找

   2.3 findVal == arr[mid]，找到，就返回

3. 结束递归条件

   3.1 找到就结束递归

   3.2 递归完整个数组，仍没有找到findVal，需要结束递归，即当left > rigtht时，左边索引大于右边索引

#### 递归二分查找

```java
public static int binarySearch(int[] arr, int left, int right, int findVal){
		// 递归完整个数组没有找到：左边的索引大于右边的索引时
		if (left > right) {
			return -1;
		}
		// 声明
		int mid = (left + right) / 2;
		int midVal = arr[mid];

		if (findVal > midVal) {
			// 向右递归
			return binarySearch(arr, mid + 1, right, findVal);
		} else if (findVal < midVal) {
			// 向左递归
			return binarySearch(arr, left, mid - 1, findVal);
		} else {
			return mid;
		}
	}
```

若数组中有重复的数字，要将所有的数值都查到，更改如下

思路分析：

1. 在找到 mid 索引值时，不要马上返回

2. 向 mid 索引值左边扫描，将所有相同的数值索引加入到集合 ArrayList

3. 向 mid 索引值右边扫描，将所有相同的数值索引加入到集合 ArrayList

4. 将 ArrayList 返回

```java
public static List<Integer> binarySearch02(int[] arr, int left, int right, int findVal){
		// 递归完整个数组没有找到：左边的索引大于右边的索引时
		if (left > right) {
			return new ArrayList<Integer>();
		}
		// 声明
		int mid = (left + right) / 2;
		int midVal = arr[mid];

		if (findVal > midVal) {
			// 向右递归
			return binarySearch02(arr, mid + 1, right, findVal);
		} else if (findVal < midVal) {
			// 向左递归
			return binarySearch02(arr, left, mid - 1, findVal);
		} else {
			// 思路分析：
			// 	1. 在找到 mid 索引值时，不要马上返回
			// 	2. 向 mid 索引值左边扫描，将所有相同的数值索引加入到集合 ArrayList
			// 	3. 向 mid 索引值右边扫描，将所有相同的数值索引加入到集合 ArrayList
			// 	4. 将 ArrayList 返回
			List<Integer> resIndexlist = new ArrayList<Integer>();
			// 向左
			int temp = mid - 1;
			while (true) {
				if (temp < 0 || arr[temp] != findVal) {
					break;
				}
				// 否则将temp 放入resIndexlist中，自动装箱功能
				resIndexlist.add(temp);
				// 左移
				temp -= 1;
			}
			// 中间的mid
			resIndexlist.add(mid);
			// 向右递归
			temp = mid + 1;
			while (true) {
				if (temp > arr.length - 1 || arr[temp] != findVal) {
					break;
				}
				// 否则将temp 放入resIndexlist中，自动装箱功能
				resIndexlist.add(temp);
				// temp 右移
				temp += 1;
			}

			return resIndexlist;
		}
	}		
```

#### 非递归二分查找

O(logN)

```java
public static int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target){
            return mid;
        } else if(target < arr[mid]) {
            // 向左查找
            right = mid - 1;
        } else {
            // 向右查找
            left = mid + 1;
        }
    }
    return -1;
}
```

### 插值查找

### 斐波那契查找

## 递归

递归调用机制，画递归树

1. 当程序执行到一个方法时，就会开辟一个独立的空间（栈）
2. 每个空间的数据（局部变量）都是独立的

可以解决的问题：

1. 八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题
2. 各种算法也可用到，快排，归并排序，二分，分治算法
3. 将要用栈解决的问题，使用递归代码比较简洁

规则：

1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量是独立的，不会相互影响；如果是引用类型的变量，就会共享该引用类型的数据，例如**数组**
3. 递归必须向退出递归的条件逼近，否则就是无限递归了
4. 当一个方法执行完毕，或者遇到return，就会返回。谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### 递归时间复杂度

master 公式，`T(N) = a * T(N / b) + O(N ^ d) `。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20211123142919825.png)

### 暴力递归

#### 基本法则

- 基准情形，base case，必须有某些基准情形，无需递归就能算出。
- 不断推进，对于需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。
- 设计法则，假设所有递归都能运行。
- 合成效益法则， 求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。

**栈逆序**

```java
// 实现 stack 的逆序
public static void reverse(Stack<Integer> stack) {
    if (stack.isEmpty()) {
        return;
    }
    int i = f(stack);
    reverse(stack);
    stack.push(i);
} 

// 将栈底的元素返回，其余的元素依次向下移动
public static int f(Stack<Integer> stack) {
    int result = stack.pop();
    if (stack.isEmpty()) {
		return result;
    }
    int last = f(stack);
    // 将剩余的元素压入栈
    stack.push(result);
    // 栈底元素
    return last;
}
```

### 回溯

适合由多个步骤组成的问题，每个步骤都有多个选项，选择了其中一个选项时，进入下一步又面临新的选项，重复做选择，直至到达最终的状态。

## 分治算法

将一个复杂的问题分解成两个或者相似的子问题，一直分解下去，直至可以直接求解，原问题的解就是子问题的合并。如快速排序，归并排序，二分搜索，大整数乘法，棋盘覆盖，线性时间选择，最接近点对问题，循环赛日程表，汉诺塔。

汉诺塔：

1. 如果只有一个盘，A -> C。如果n >= 2的情况，总是可以看成最下面一个盘，还有上面所有的盘作为一个整体
2. 先把最上边的盘从A -> B
3. 把下边的盘A -> C
4. 把B塔所有的盘从B -> C 

## 贪心算法

局部最优 -> 全局最优。使用堆(PriorityQueue)和排序

**解题套路：**

- 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
- 脑补贪心策略A、B、C...
- 用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
- 不要纠结贪心策略的证明

> 给一个数据流，随时返回中位数：
>
> - 准备一个大根堆和一个小根堆
> - 若 cur <= 大根堆的堆顶，加入大根堆，否则加入小根堆
> - 大根堆与小根堆的长度比较，一旦差值到达2，将长度大的堆顶的数据加入较小的一个中去

## KMP

当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这部分信息避免从头再去匹配。

**next 数组**：前缀表（prefix table），记录相同前后缀的最大长度。用来回退的，当模式串与主串不匹配的时候，该表记录了**模式串**应该从哪里开始重新匹配。前缀表就是下标 i 之前（包含 i ）的字符串中，相同前缀后缀的最大长度。

**前缀**，不包含最后一个字符的，以第一个字符为首的连续子串

**后缀**，不包含第一个字符的，以最后一个字符为结尾的连续子串

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/kmp.jpg)

1. X、Y位置的字符不同，X不动，Y到最大前缀字串的下一个字符，再进行比较。

2. 会与最大前后缀匹配长度矛盾，假设能匹配上，会出现更长的匹配长度，相矛盾。

```java
/**
* @param s 较长的字符串
* @param m 要匹配的字符串
* @return 字符串 m 开始的位置
*/
public static int getIndexOf(String s, String m) {
    if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
        return -1;
    }
    char[] str1 = s.toCharArray();
    char[] str2 = m.toCharArray();
    // str1 中要比对的位置 x
    int x = 0;
    int y = 0;
    int[] next = getNextArray(str2);

    // O(N)
    while (x < str1.length && y < str2.length) {
        if (str1[x] == str2[y]) {
            x++;
            y++;
        } else if (y == 0) {
            // next[y] == -1
            // str2 来到了头节点的位置，已经无法往前跳了，需要 str1 向下移动一位继续匹配
            x++;
        } else {
            // x 不动，y 往后推进行匹配
            y = next[y];
        }
    }
    // y 越界了
    return y == str2.length ? x - y : -1;
}

private static int[] getNextArray(char[] str) {
    if (str.length == 1) {
        return new int[]{-1};
    }
    int[] next = new int[str.length];
    next[0] = -1;
    next[1] = 0;
    // next 数组的位置
    int i = 2;
    // 目前是哪个位置的字符与 i-1 位置的字符比较
    // 最大前后缀字串的长度
    int cn = 0;

    // O(M)
    while (i < next.length) {
        if (str[i - 1] == str[cn]) {
            // i-1 位置的字符与 cn 位置的字符相同
            next[i++] = ++cn;
        } else if (cn > 0) {
            // 当前跳到 cn 位置的字符，和 i-1 位置的字符配不上
            cn = next[cn];
        } else {
            next[i++] = 0;
        }
    }

    return next;
}
```

## Manacher

回文半径、回文直径，回文半径数组，之前扩的所有位置中到达最右回文右边界，取得最远边界时，中心的下标。

1. 当前来到的点**不在**最右回文右边界里，就暴力解

2. 当前来到的点**在**最右回文右边界里

    ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/manacher.png)

   - i' 的回文区域在L...R里面，i 的回文半径就是 i' 的回文半径

   - i' 的回文区域一部分在L...R外面，i 到 R就是回文半径

   - i' 的回文区域边界与 L 重合，R' 到 R 之间的区域不需要验证，之外需要自己验证

    ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/manacher1.jpg)

```java
public static int manacher(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    // "12132" -> "#1#2#1#3#2#"
    char[] str = manacherString(s);
    // 回文半径的大小
    int[] pArr = new int[str.length];
    int C = -1;
    // 讲述中：R代表最右的扩成功的位置
    // coding：最右的扩成功位置的，再下一个位置
    int R = -1;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < str.length; i++) { // 0 1 2
        // R第一个违规的位置，i>= R
        // 至少不用验证的区域
        // i位置扩出来的答案，i位置扩的区域，至少是多大。  2 * C - i 是 i' 的位置
        pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1;
        while (i + pArr[i] < str.length && i - pArr[i] > -1) {
            // 至少不用验证的区域，左右是否可以扩大
            if (str[i + pArr[i]] == str[i - pArr[i]])
                pArr[i]++;
            else {
                break;
            }
        }
        if (i + pArr[i] > R) {
            R = i + pArr[i];
            C = i;
        }
        max = Math.max(max, pArr[i]);
    }
    // 原串最大回文字串长度
    return max - 1;
}

public static char[] manacherString(String str) {
    char[] charArr = str.toCharArray();
    char[] res = new char[str.length() * 2 + 1];
    int index = 0;
    for (int i = 0; i != res.length; i++) {
        res[i] = (i & 1) == 0 ? '#' : charArr[index++];
    }
    return res;
}

// for test
public static int right(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = manacherString(s);
    int max = 0;
    for (int i = 0; i < str.length; i++) {
        int L = i - 1;
        int R = i + 1;
        while (L >= 0 && R < str.length && str[L] == str[R]) {
            L--;
            R++;
        }
        max = Math.max(max, R - L - 1);
    }
    return max / 2;
}
```

## 树型DP

- 树形dp套路第一步：
  以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的
- 树形dp套路第二步：
  根据第一步的可能性分析，列出所有需要的信息
- 树形dp套路第三步：
  合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构
- 树形dp套路第四步：
  设计递归函数，递归函数是处理以 X 为头节点的情况下的答案。包括设计递归的base case，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤

二叉树中求两个节点之间的**最大距离**。

```java
class Node {
    public int value;
    public Node left;
    public Node right;
    
	public Node(int data) {
        this.value = data;
    }    
}

class Info {
    private int maxDistance;
    private int height;
    
    public Info(int m, int h) {
        maxDistance = m;
        height = h;
    }
}

// 返回以 x 为头节点整棵树的两个信息
public static Info process(Node x) {
    if (x == null) {
        return new Info(0, 0);
    }
    
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    
    int p1 = leftInfo.maxDistance;
    int p2 = rightInfo.maxDistance;
    int p3 = leftInfo.height + rightInfo.height + 1;
    int maxDistance = Math.max(p1, Math.max(p2, p3));
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    
    return new Info(maxDistance, height);
}

public static int maxDistanceTree(Node head) {
    return process(head).maxDistance;
}
```

### Morris遍历 

通过利用二叉树中大量空闲指针的方式，达到节省空间的目的。时间复杂度O(N)，额外空间复杂度O(1)。

`节点有左孩子，该节点会遍历两次，没有左孩子只遍历一次`

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20211228200710310.png)

```java
public static void morris(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {
        // mostRight 是 cur 的左孩子
        mostRight = cur.left;
        // 有左子树
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                // 最右节点
                mostRight = mostRight.right;
            }
            // mostRight 变成了 cur 左子树上最右节点
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                // mostRight == cur
                mostRight.right = null;
            }
        }
        // 没有左子树，cur 向右移动
        cur = cur.right;
    }
}
```

### 先序遍历

节点只到一次就直接打印，如果有两次回到的节点打印第一次就行。

```java
public static void morrisPre(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {
        // mostRight 是 cur 的左孩子
        mostRight = cur.left;
        // 有左子树
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                // 最右节点
                mostRight = mostRight.right;
            }
            // mostRight 变成了 cur 左子树上最右节点
            if (mostRight.right == null) {
                System.out.print(cur.value + " ");
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                // mostRight == cur
                mostRight.right = null;
            }
        } else {
            // 第一次出现
            System.out.print(cur.value + " ");
        }
        // 没有左子树，cur 向右移动
        cur = cur.right;
    }
}
```

### 中序遍历

节点只到一次就直接打印，如果有两次回到的节点打印第二次就行。可以用于判断搜索二叉树BST，保证中序遍历是升序的。

```java
public static void morrisIn(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
            }
        }
        System.out.print(cur.value + " ");
        cur = cur.right;
    }
    System.out.println();
}
```

### 后序遍历

节点只到一次的不用处理，节点到两次的，在第二次到达的时候逆序打印左树的右边界。整个过程完成以后，单独逆序打印整棵树的右边界。

```java
public static void morrisPos(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
                printEdge(cur.left);
            }
        }
        cur = cur.right;
    }
    printEdge(head);
    System.out.println();
}

// 以 head 为头的树，逆序打印这棵树右边界
public static void printEdge(Node head) {
    Node tail = reverseEdge(head);
    Node cur = tail;
    while (cur != null) {
        System.out.print(cur.value + " ");
        cur = cur.right;
    }
    reverseEdge(tail);
}

public static Node reverseEdge(Node from) {
    Node pre = null;
    Node next = null;
    while (from != null) {
        next = from.right;
        from.right = pre;
        pre = from;
        from = next;
    }
    return pre;
}
```

## 大数据题目

资源限制类题目：

 - 哈希函数可以把数据按照种类均匀分流
 - 布隆过滤器用于集合的建立与查询,并可以节省大量空间
 - 一致性哈希解决数据服务器的负载管理问题
 - 利用并查集结构做岛问题的并行计算
 - 位图解决某一范围上数字的出现情况，并可以节省大量空间
 - 利用分段统计思想 、并进一步节省大量空间
 - 利用堆、外排序来做多个处理单元的结果合并


- **40亿个数（范围为0 ~ 2 ^ 32 - 1）找没有出现过的数，内存限制为 m KB**

  内存大小除以无符号整形数组单个元素大小 4 字节， 可以开 m / 4 范围的整型数组，找最近的离该数小的 2 的某次方的数，将整型数组大小设置为它，假设为 length。将0 ~ 2 ^ 32 - 1范围的数划分为 length 份（每一份都是等量的，2^32 / length 能整除）。

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/wordFrequency.jpg)

  40亿个数肯定不够 2^32 个，数组的某个位置上有不够2^32 / length 的，然后继续重复操作找该没有出现的数。

- **有一个包含100亿个 URL 的大文件，假设每个 URL 占用 64B，请找出其中所有重复的 URL**

  使用哈希函数或者布隆过滤器 

- **某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门 Top100 词汇的可行办法**

  将数据分成多个**大根堆**的形式，每个大根堆的堆顶加入到另一个容量为 100 的大根堆，总堆中每弹出一个词汇，将该词汇原来的大根堆中删除该词汇后的堆顶进入总堆中，周而复始进行 100 次弹出就是 Top100 的词汇。时间复杂度 O(logN)

- **（19年 Tncent 二面）硬盘中10G文件，包含是无序的有符号整数（-2^31^ ~ 2^31^ -1），给定5G内存，将其变成有序的，保存在另一个文件中**

  法1：堆的技巧

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/10GSort.jpg)

  法2：开辟一个较小的大根堆，标志temp，用于记录小于等于 temp 的数已经排过序了，遍历文件，将文件中较小的符合大根堆长度的加入里面，按要求打印大根堆，更新temp，再过滤掉小于等于temp的数，再遍历，加入大根堆，直到完全排完。

## 位运算

- 给定两个有符号32位整数a、b，不用作判断返回其中较大的。

  ```java
  /**
  * @param n 0 or 1
  * @return 1 -> 0 or 0 -> 1
  */
  public static int flip(int n) {
      return n ^ 1;
  }
  
  /**
  * @param n 整数
  * @return 非负数返回 1，负数返回 0
  */
  public static int sign(int n) {
      return flip((n >> 31) & 1);
  }
  
  public static int getMax1(int a, int b) {
      // 这里有可能会溢出
      int c = a - b;
      // c 为非负，返回 1；为负，返回 0
      int scA = sign(c);
      int scB = flip(scA);
      return a * scA + b * scB;
  }
  
  public static int getMax2(int a, int b) {
      // 处理了会溢出的情况
      int c = a - b;
      int sa = sign(a);
      int sb = sign(b);
      int sc = sign(c);
      // a、b符号位相同为0，不同为1
      int difSab = sa ^ sb;
      int sameSab = flip(difSab);
      // difSab * sa : a、b 符号不同并且 a > 0，返回 a
      // sameSab * sc : a、b 符号相同，返回差值的符号，a - b >= 0,返回 a
      // 以上两个条件互斥
      int returnA = difSab * sa + sameSab * sc;
      int returnB = flip(returnA);
      return returnA * a + returnB * b;
  }
  ```

- 判断一个32位整数是否是2的幂和4的幂。

  2的幂 - 判断该整数的二进制码是否只有一位是1；4的幂 - 在是2的幂的前提下，判断该整数二进制码1是否在偶数位上。

  判断只有一个1：X & (X - 1) == 0；X == X & (~X + 1)（最右边第一个为1的数）

  判断是否是4的幂：X & 01010101 01010101 01010101 01010101 != 0

  ```java
  public static boolean is2Power(int n) {
      return (n & (n - 1)) == 0;
  }
  
  public static boolean is4Power(int n) {
      return (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
  }
  ```


- 给定两个有符号 32 位整数 a 和 b ，不能使用算术运算符，分别实现 a 和 b 的加减乘除运算。

  加法：先进行异或（无进位相加）运算，再两个数相与左移一位（进位信息）。

  减法：正数 n 的补码按位取反得到负数的补码，减一后再取反得到负数 -(n + 1)。

  乘法：类似于正常的乘法运算，哪个位置为1就将另一个数向左移动该位置上的数，累加求值。

  除法：运用乘法的思想，将除数向左移动到不超过被除数的首位，结果中包含移位后的除数的最右面的1。向左移的时候可能会出现符号位变化，数据会错误，所以条件判断可以将被除数右移。

  ```java
  // 适用于数据没有溢出的情况
  public static int add(int a, int b) {
  	int sum = a;
      while (b != 0) {
          // 无进位相加
          sum = a ^ b;
          // 进位信息
          b = (a & b) << 1;
          a = sum;
      }
      return sum;
  }
  
  // 相反数
  public static int negNum(int n) {
      return add(~n, 1);
  }
  
  public static int minus(int a, int b) {
      // add(~b, 1) 就是 b 的相反数，-b
      return add(a, negNum(b));
  } 
  
  public static int multi(int a, int b) {
      int res = 0;
      while (b != 0) {
          // b 最右面的位为0的时候不加
  		if ((b & 1) != 0) {
              res = add(res, a);
          }
          // a 左移一位，b 无符号右移一位
          a <<= 1;
          b >>>= 1;
      }
      return res;
  }
  
  public static boolean isNeg(int n) {
      return n < 0;
  }
  
  public static int div(int a, int b) {
      int x = isNeg(a) ? negNum(a) : a;
      int y = isNeg(b) ? negNum(b) : b;
      int res = 0;
      for (int i = 31; i >= 0; i = minus(i, 1)) {
          if ((x >> i) >= y) {
              // 包含最右边的1
              res |= (1 << i);
              // 减去 y 左移后继续
              x = minus(x, y << i);
          }
      }
      return res;
  }
  ```

## 01 背包

有 n 件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i]。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

暴力的解法就是利用回溯，时间复杂度是指数级别的，需要用动态规划去进行优化。

### 二维 dp 数组 01 背包

1. dp 数组以及下标的含义

   `dp[i][j]`表示从下标为 `0-i` 的物品任意取，放进容量为 j 的背包，价值总和最大是多少。

2. 递推公式

   - 不放物品，可以由 `dp[i - 1][j]`推出，因为物品 i 没有放入背包中，就是物品 i 的重量大于背包最大重量时。
   - 放物品，由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]]`是背包容量为`j - weight[i]`时，不放物品 i 的最大价值。那么背包放物品 i 得到的最大价值就是`dp[i - 1][j - weight[i]] + value[i]`。

   ```java
   dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
   ```

3. 初始化

   如果背包的重量为 0 的时候，无论选取那件物品，背包的价值总和一定为 0，即`dp[i][0] = 0`。

   根据递推公式可以看出，首行`dp[0][j]`也需要进行初始化，`j < weight[0] -> dp[0][j] = 0  j >= weight[0] -> dp[0][j] = value[0]`。

   ```java
   for (int j = 1; j < dp[0].length; j++) {
       if (j < weight[0]) {
           dp[0][j] = 0;
       } esle {
           dp[0][j] = value[0];
       }
   }
   // 等价于
   for (int j = 0; j < weight[0]; j++) {
       dp[0][j] = 0;
   }
   for (int j = weight[0]; j <= bagweight; j++) {
       dp[0][j] = value[0];
   }
   ```

4. 确定遍历顺序

   有两个遍历的维度，物品与背包重量。选择先遍历物品再遍历重量。

   ```java
   // weight 数组的大小，就是物品的数量，先遍历物品
   for (int i = 1; i < weight.length; i++) {
       // 遍历容量
       for (int j = 0; j <= bagweight; j++) {
           if (j < weight[i]) {
               dp[i][j] = dp[i - 1][j];
           } else {
               dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
           }
       }
   }
   ```

5. 举例推导 dp 数组

```java
public static void main(String[] args) {
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagSize = 4;
    testWeightBag(weight, value, bagSize);
}

private static void testWeightBag(int[] weight, int[] value, int bagSize) {
    // dp[i][j] 表示从 0 - i 选取物品放入背包 j 获得的最大价值
    int wlen = weight.length;
    // +1 是为了方便利用上一层的数据进行初始化，减少代码量
    int[][] dp = new int[wlen + 1][bagSize + 1];
    
    for (int i = 1; i <= wlen; i++) {
        for (int j = 1; j <= bagSize; j++) {
            // 从 weight[0] 开始和背包判断，隐含了初始化
            if (j < weight[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
            }
        }
    }
    
    for (int i = 0; i <= wlen; i++) {
        for (int j = 0; j <= bagSize; j++) {
            System.out.print(dp[i][j] + " ");
        }
        System.out.print("\n");
    }
}
```

### 滚动数组

一维数组，`dp[j]`的含义：容量为 j 的背包，所背的物品价值可以最大为`dp[j]`。

递推公式：`dp[j] = Math.max(dp[j], dp[j - weight[i]] + vlaue[i])`

```java
public static void main(String[] args) {
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagSize = 4;
    testWeightBag(weight, value, bagSize);
}

private static void testWeightBag(int[] weight, int[] value, int bagSize) {
    // 一维 dp
    int wlen = weight.length;
    int[] dp = new int[bagSize + 1];
    // 先遍历物品，再遍历背包
    for (int i = 0; i < wlen; i++) {
        for (int j = bagSize; j >= weight[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    
    //打印dp数组
    for (int j = 0; j <= bagWeight; j++){
        System.out.print(dp[j] + " ");
    }
}
```

## 完全背包

与 01 背包不同的是，每种物品有无限件。

01 背包一维 dp ，先遍历物品再遍历背包。完全背包，从小到大遍历背包容量，物品与背包的遍历先后顺序不影响最后结果。

```java
for (int i = 0; i < weight.length; i++) {
    for (int j = weight[i]; j <= bagSize; j++) {
        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```



## 递归->动态规划

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/dynamicPlanning.png)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/robotWalk.jpg)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220105093454687.png)

```java
public static int walkWays(int N, int E, int S, int K) {
    return func(N, E, K, S);
}

/**
* @param N 一共的位置数，固定值
* @param E 最终的目标，固定值
* @param rest 还剩 rest 步需要走
* @param cur 当前在的位置
* @return 方法数
*/ 
public static int func(int N, int E, int rest, int cur) {
    // base case
    if (rest == 0) {
        return cur == E ? 1 : 0;
    }
    // rest > 0 还有路可以走
    if (cur == 1) {
        // 1 -> 2
        return func(N, E, rest - 1, 2);
    }
    if (cur == N) {
        // N-> N - 1
        return func(N, E, rest - 1, N - 1);
    }
    // 机器人来到的中间位置
    return func(N, E, rest - 1, cur + 1) + func (N, E, rest - 1, cur - 1);
}

public static int memoWalkWays(int N, int E, int S, int K) {
    int[][] dp = new int[K + 1][N + 1];
    for (int i = 0; i <= K; i++) {
        for (int j = 0; j <= N; j++) {
            dp[i][j] = -1;
        }
    }
    return memoFunc(N, E, K, S, dp);
}

public static int memoFunc(int N, int E, int rest, int cur, int[][] dp) {
    // 状态之前算过
    if (dp[rest][cur] != -1) {
        return dp[rest][cur];
    }
    int res;
    if (rest == 0) {
        res = (cur == E) ? 1 : 0;
    } else if (cur == 1) {
        res = memoFunc(N, E, rest - 1, 2, dp);
    } else if (cur == N) {
        res = memoFunc(N, E, rest - 1, N - 1, dp);
    } else {
        res = memoFunc(N, E, rest - 1, cur + 1, dp) + memoFunc(N, E, rest - 1, cur - 1, dp);
    }
    dp[rest][cur] = res;
    return res;
}

public static int dpWalkWays(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
        return -1;
    }
    // 行是 N 的点数，列是要走的步数
    int[][] dp = new int[N + 1][K + 1];
    // base case
    dp[aim][0] = 1;
    for (int rest = 1; rest <= K; rest++) {
        dp[1][rest] = dp[2][rest - 1];
        for (int cur = 2; cur < N; cur++) {
            dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
        }
        dp[N][rest] = dp[N - 1][rest - 1];
    }
    return dp[start][K];
}
```

- 一组数字，两人分别从该组数字中的两头取一个数字，最后求手中数字总和最大的获胜。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220105101157575.png)

```java
// 根据规则，返回获胜者的分数
public static int win(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int first = f1(arr, 0, arr.length - 1);
    int second = g1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}

// arr[L...R]，先手获得最好的分数返回
// 当前该你拿
public static int f1(int[] arr, int L, int R) {
    if (L == R) {
        return arr[L];
    }
    // 如果拿的是中间的，返回自己拿掉这个后，自己后手拿的最大的那一种情况
    return Math.max(arr[L] + g1(arr, L + 1, R), arr[R] + g1(arr, L, R - 1));
}

// arr[L...R]，后手获得最好的分数返回
// 当前不该你拿，是对方在 arr[L...R] 上拿
public static int g1(int[] arr, int L, int R) {
    if (L == R) {
		return 0;
    }
    // 对方拿了 L 位置的数
    int p1 = f1(arr, L + 1, R);
    // 对方拿了 R 位置的数
    int p2 = f1(arr, L, R - 1);
    return Math.min(p1, p2);
}

public static int dpWin(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int N = arr.length;
    int[][] fmap = new int[N][N];
    int[][] gmap = new int[N][N];
    // base case
    for (int i = 0; i < N; i++) {
        fmap[i][i] = arr[i];
    }
    for (int startCol = 1; startCol < N; startCol++) {
        int L = 0;
        int R = startCol;
        while (R < N) {
            // 平行于对角线上的值先填
            fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]);
            gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]);
            L++;
            R++;
        }
    }
    return Math.max(fmap[0][N - 1], gmap[0][N - 1]);
}
```

### 三维DP

当前来到的位置是（x,y），还剩下rest步需要跳。跳完rest步，正好跳到a，b的方法数是多少？10 * 9 的大小。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/horseJump.jpg)

```java
class HorseJump {
    public static int jump(int a, int b, int k) {
        return process(0, 0, k, a, b);
    }
    
    public static int process(int x, int y, int rest, int a, int b) {
        // 越界
        if (x < 0 || x > 9 || y < 0 || y > 8) {
            return 0;
        }
        // base case
        if (rest == 0) {
            return (x == a && y == b) ? 1 : 0;
        }
        // 向8个方向跳
        int res = process(x + 2, y + 1, rest - 1, a, b);
        res += process(x + 1, y + 2, rest - 1, a, b);
        res += process(x - 1, y + 2, rest - 1, a, b);
        res += process(x - 2, y + 1, rest - 1, a, b);
        res += process(x - 2, y - 1, rest - 1, a, b);
        res += process(x - 1, y - 2, rest - 1, a, b);
        res += process(x + 1, y - 2, rest - 1, a, b);
        res += process(x + 2, y - 1, rest - 1, a, b);
        return res;
    }
    
    // 从(a, b) 到(0, 0)走 k 步
    public static int dpJump(int a, int b, int k) {
        int[][][] dp = new int[10][9][k + 1];
        // base case
        dp[a][b][0] = 1;
        for (int rest = 1; rest <= k; rest++) {
            for (int x = 0; x < 10; x++) {
                for (int y = 0; y < 9; y++) {
                    int res = getValue(dp, x + 2, y + 1, rest - 1);
                    res += getValue(dp, x + 1, y + 2, rest - 1);
                    res += getValue(dp, x - 1, y + 2, rest - 1);
                    res += getValue(dp, x - 2, y + 1, rest - 1);
                    res += getValue(dp, x - 2, y - 1, rest - 1);
                    res += getValue(dp, x - 1, y - 2, rest - 1);
                    res += getValue(dp, x + 1, y - 2, rest - 1);
                    res += getValue(dp, x + 2, y - 1, rest - 1);
                    dp[x][y][rest] = res;
                }
            }
        }
        return dp[0][0][k];
    }
    
    public static int getValue(int[][][] dp, int x, int y, int rest) {
        if (x < 0 || x > 9 || y < 0 || y > 8) {
            return 0;
        }
        return dp[x][y][rest];
    }
}
```

### 零钱兑换

#### 斜率优化

斜率优化，有枚举行为，观察两个相邻位置是否满足相应的关系。只和观察有关，和原题意无关。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/CoinsWays.jpg)

```java
public class CoinsWays {
	// arr 都是不重复的正数，每一个值代表一种货币，每一种都可以用无限张
	// aim 是要找的零签数
	// return 找零的方法数
	public static int way(int[] arr, int aim) {
		return process(arr, 0, aim);
	}
	
	// 可以自由使用 arr[index...] 所以的面值
	// 需要找零的钱数
	// 返回找零的方法数
	public static int process(int[] arr, int index, int rest) {
		if (index == arr.length) {
			return rest == 0 ? 1 : 0;
		}
		int res = 0;
		for (int zhang = 0; arr[index] * zhang <= rest; zhang++) {
			res += process(arr, index + 1, rest - arr[index] * zhang);
		}
		return res;
	}
    
    public static int dpWay(int[] arr, int aim) {
        if (arr.length == 0 || arr == null || aim < 0) {
            return 0;
        }
        int N = arr.length;
        int[][] dp = new int[N + 1][aim + 1];
        // base case
        dp[N][0] = 1;
        // 位置依赖
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                int res = 0;
                // 改写递归函数
                for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
                    res += dp[index + 1][rest - zhang * arr[index]];
                }
                dp[index][rest] = res;
            }
        }
        return dp[0][aim];
    }
    
    // 斜率优化
    public static int optimizeDpWay(int[] arr, int aim) {
        if (arr.length == 0 || arr == null || aim < 0) {
            return 0;
        }
        int N = arr.length;
        int[][] dp = new int[N + 1][aim + 1];
        // base case
        dp[N][0] = 1;
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest] = dp[index + 1][rest];
                // 保证不越界，将枚举的行为变成与之前的尝试过的数目相加
                if (rest - arr[index] >= 0) {
                    dp[index][rest] += dp[index][rest - arr[index]];
                }
            } 
        }
    	return dp[0][aim];    
    }
}
```
