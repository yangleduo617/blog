# 数据结构

## 线性结构

数组、队列、链表（地址不连续）、栈

### 稀疏数组

当一个数组中大部分值为0或者同一个数时，可以用稀疏数组保存该数组，可以优化二维数组。

数理方法：

1. 记录数组一共几行几列，有多少不同的值

2. 把不同值的元素的行列及值记录在小规模的数组（稀疏数组）中

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/稀疏数组.png)

二维数组与稀疏数组之间转换：

1. 二维数组转稀疏数组：

   （1）遍历原始的二维数组，得到有效数据的个数sum

   （2）根据sum就可以创建稀疏数组 `sparseArr int[sum + 1][3]`

   （3）将二维数组的有效数据存入到sparseArr

   （4）将稀疏数组保存到磁盘

2. 稀疏数组转二维数组：

   （1）将磁盘对应稀疏数组的文件恢复成稀疏数组

   （2）读取稀疏数组的第一行，根据第一行的数据，创建原始二维数组，例如上面`oriArr = int[6][7]`

   （3）再读取稀疏数组后几行的数据，并赋值给上述创建的二维数组

### 队列

例如银行排序，队列是一个有序表，可用数组或链表实现。遵循**先入先出**原则。数组模拟：

写入数据在队列的尾部加，读取数据在队列的首部读取。因此需要两个变量front和rear分别记录队列前后端的下标。front会随着数据的输出改变，rear随着数据的输入而改变。

将数据存入队列时，注意：

1. 将尾指针右移，rear + 1，当front == rear时队列为空

2. 若尾指针rear 小于队列的最大下标maxSize - 1，将数据存入rear所指的数组元素中，否则无法存入数据，rear= maxSize - 1时，队列满。 

### 链表（Linked List）

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/linkedlist.png)

注意：

1. 链表是以节点的方式来存储， **是链式存储** 

2. 每个节点包含 data 域， next 域：指向下一个节点

3. 如图：发现**链表的各个节点不一定是连续存储**

4. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

#### 面试注意

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20211125140044235.png)

### 回文链表

面试的时候使用O(N)时间复杂度，空间复杂度O(1)，使用快慢指针将链表划分两个部分，后部分反转，进行判断，再将链表恢复。

```java
public static class Node {
	public int value;
	public Node next;

	public Node(int data) {
		this.value = data;
	}
}

// need n extra space
public static boolean isPalindrome1(Node head) {
	Stack<Node> stack = new Stack<Node>();
	Node cur = head;
	while (cur != null) {
		stack.push(cur);
		cur = cur.next;
	}
	while (head != null) {
		if (head.value != stack.pop().value) {
			return false;
		}
		head = head.next;
	}
	return true;
}

// need n/2 extra space
public static boolean isPalindrome2(Node head) {
	if (head == null || head.next == null) {
		return true;
	}
	Node right = head.next;
	Node cur = head;
	while (cur.next != null && cur.next.next != null) {
		right = right.next;
		cur = cur.next.next;
	}
	Stack<Node> stack = new Stack<Node>();
	while (right != null) {
		stack.push(right);
		right = right.next;
	}
	while (!stack.isEmpty()) {
		if (head.value != stack.pop().value) {
			return false;
		}
		head = head.next;
	}
	return true;
}

// need O(1) extra space
public static boolean isPalindrome3(Node head) {
	if (head == null || head.next == null) {
		return true;
	}
	Node n1 = head;
	Node n2 = head;
	while (n2.next != null && n2.next.next != null) { // find mid node
		n1 = n1.next; // n1 -> mid
		n2 = n2.next.next; // n2 -> end
	}
	// n1 中点

	n2 = n1.next; // n2 -> right part first node
	n1.next = null; // mid.next -> null
	Node n3 = null;
	while (n2 != null) { // right part convert
		n3 = n2.next; // n3 -> save next node
		n2.next = n1; // next of right node convert
		n1 = n2; // n1 move
		n2 = n3; // n2 move
	}
	n3 = n1; // n3 -> save last node
	n2 = head;// n2 -> left first node
	boolean res = true;
	while (n1 != null && n2 != null) { // check palindrome
		if (n1.value != n2.value) {
			res = false;
			break;
		}
		n1 = n1.next; // left to mid
		n2 = n2.next; // right to mid
	}
	n1 = n3.next;
	n3.next = null;
	while (n1 != null) { // recover list
		n2 = n1.next;
		n1.next = n3;
		n3 = n1;
		n1 = n2;
	}
	return res;
}
```

### 复制带随机指针的链表

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
			return null;
		}
		Node cur = head;
		Node next = null;
		// copy node and link to every node
		// 1 -> 2
		// 1 -> 1' -> 2
		while (cur != null) {
			// cur 老 next 老的下一个
			next = cur.next;
			// 复制出当前节点，老的节点指向它
			cur.next = new Node(cur.val);
			cur.next.next = next;
			cur = next;
		}
		cur = head;
		Node curCopy = null;
		// set copy node rand
		// 1 -> 1' -> 2 -> 2'
		// 一对一对的遍历
		while (cur != null) {
			// cur 老
			// cur.next 新 copy
			next = cur.next.next;
			curCopy = cur.next;
			// cur.rand.next 就是 cur.rand 的克隆
			curCopy.random = cur.random != null ? cur.random.next : null;
			cur = next;
		}
		// head head.next
		Node res = head.next;
		cur = head;
		// split
		while (cur != null) {
			next = cur.next.next;
			curCopy = cur.next;
			cur.next = next;
			curCopy.next = next != null ? next.next : null;
			cur = next;
		}
		return res;
    }
}
```

### 环形链表

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20211125171335608.png)

- 只能是两个链表都无环，或者都有环才下相交。

- 快慢指针判断链表**是否有环**，慢指针一次走一步，快指针一次走两步，如果快指针等于空，或者快指针的下一个等于空，则没有环。如果两个指针相遇就有环，第一次相遇后，慢指针不动，快指针指向头节点，然后快慢指针一次走一步，第一次相遇后就是环链表的第一个节点。

  ```java
  public class Node {
  	public int value;
      public Node next;
      public Node(int value) {
          this.value = value;
      }
  }
  // 找到链表第一个入环节点
  public static Node getLoopNode(Node head) {
  	if (head == null || head.next == null || head.next.next == null) {
  		return null;
      }
      // slow 慢指针 fast 快指针
      Node slow = head.next;
      Node fast = head.next.next;
      while (slow != fast) {
          if (fast.next == null || fast.next.next == null) {
              return null;
          }
          slow = slow.next;
          fast = fast.next.next;
      }
      // 两个指针相遇，快指针指向头节点
      fast = head;
      while (slow != fast) {
  		slow = slow.next;
          fast = fast.next;
      }
      return slow;
  }
  ```

- 判断两个**无环链表**的相交问题，两个链表分别走到最后，记录两个链表的长度。判断最后一个节点地址是否相等，如果不相等就没有相交；长的链表先走两个链表的差值步，然后两个链表同时走，第一个相交的节点就是两个链表的交点。

  ```java
  // 两个无环链表相交问题
  public static Node noLoop(Node head1, Node head2) {
      if (head1 == null || head2 ==null) {
  		return null;
      }
      Node cur1 = head1;
      Node cur2 = head2;
      int n = 0;
      // 到最后一个节点就停
      while (cur1.next != null) {
          n++;
          cur1 = cur1.next;
      }
      while (cur2.next != null) {
  		n--;
          cur2 = cur2.next;
      }
      // 最后一个节点地址不相等就返回 null
      if (cur1 != cur2) {
  		return null;
      }
      // 较长的链表赋给 cur1
      cur1 = n > 0 ? head1 : head2;
      cur2 = cur1 == head1 ? head2 : head1;
      n = Math.abs(n);
      // 长链表走差值步
      while (n != 0) {
          n--;
          cur1 = cur1.next;
      }
  	// 两个链表一起走
      while (cur1 != cur2) {
  		cur1 = cur1.next;
          cur2 = cur2.next;
      }
      return cur1;
  }
  ```

- 两个有环链表，①不相交，②相交的头节点是同一个，③ 相交的头节点不同

  ```java
  /** 两个有环链表相交判断
  	 * @Author   yyw
  	 * @DateTime 2021-11-26T10:11:43+0800
  	 * @param    head1                    [description]
  	 * @param    loop1                    第一个链表的第一个入环节点
  	 * @param    head2                    [description]
  	 * @param    loop2                    第二个链表的入环节点
  	 * @return                            
  	 */
  public static Node bothLoop(Node head1, Node loop2, Node head2, Node loop2) {
    Node cur1 = null;
    Node cur2 = null;
    if (loop1 == loop2) {
        // 第二种情况，相当于无环链表的判断
    cur1 = head1;
        cur2 = head2;
        int n = 0;
        while (cur1 != loop1) {
        n++;
            cur1 = cur1.next;
        }
        while (cur2 != loop2) {
            n--;
            cur2 = cur2.next;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while (n != 0) {
        n--;
            cur1 = cur1.next;
        }
        while (cur1 != cur2) {
        cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    } else {
        cur1 = loop1.next;
        while (cur1 != loop1) {
            if (cur1 == loop2) {
            return loop1;
            }
        cur1 = cur1.next;
        }
        return null;
    }
      
  }
  ```

## 非线性结构

二维数组、多维数组、广义表、树结构、图结构

### 哈希表（散列表）

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20211125092505912.png)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20211125094701794.png)

### 布隆过滤器

应用于黑名单系统。BitMap 的 bit 的长度决定失误率。K 个哈希函数是由样本的固有数量和 BitMap 的长度决定的。 单个样本的大小与布隆过滤器设计多大没有关系，只要哈希函数能够接收样本值就行。 

n 样本量，P 预期的失误率 ，算出小数向上取整。真实的m可以根据实际的内存适当的增加，这样可以降低真实失误率。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220717185838806.png)


```java
class BitMap {
    // 32 bit * 10 -> 320 bits
    int[] arr = new int[10]; 
    // 获取178位 bit 的状态
    int i = 178;
    int numIndex = 178 / 32;
    int bitIndex = 178 % 32;
    
    // 拿到178位的状态
    int s = ((arr[numIndex] >> bitIndex) & 1);
    
    // 将178位的状态改为1
    arr[numIndex] = arr[numIndex] | (1 << bitIndex);
    
    // 将178位的状态改为0
    arr[numIndex] = arr[numIndex] & (~ (1 << bitIndex));
}
```

### 一致性哈希

- 选择哈希 Key 的时候要选择种类比较多的那个，这样可以更好的负载均衡。

- 服务器数量少的时候，怎样确保数据均分；在增加机器的时候，解决负载不均衡的问题。使用**虚拟节点**技术。

## 树结构

没有回路的连通无向图，任意两个结点有且仅有一条路径。递归解决一切树形DP问题，需要从左右子树要信息，在后面处理这些信息需要满足的条件。

### 深度优先遍历

```java
class Node<V> {
	V value;
    Node left;
    Node right;
}
```

用**递归和非递归**两种方式实现二叉树的先序、中序、后序遍历。

**递归**

- 先序遍历，先打印头节点，再打印左子树全部节点，最后打印右子树所有节点。使用递归序打印时，只有第一次才进行打印操作。

  ```java
  public static void pre(Node head) {
  	if (head == null) {
  		return;
      }
      System.out.println(head.value);
      pre(head.left);
      pre(head.right);
  }
  ```

- 中序遍历，每一棵子树，按照左子树节点、头节点、右子树节点的顺序打印。使用递归序，只有第二次到头节点时再打印

  ```java
  public static void in(Node head) {
      if (head == null) {
          return;
      }
      in(head.left);
      System.out.println(head.value);
      in(head.right);
  }
  ```

- 后序遍历，每一棵子树，按照左子树节点、右子树节点、头节点的顺序。使用递归序，只有第三次到头节点再打印。

  ```java
  public static void pos(Node head) {
  	if (head == null) {
  		return;
      }
      pos(head.left);
      pos(head.right);
      System.out.println(head.value);
  }
  ```

**非递归**

- 先序遍历，将头节点压入栈。从栈中弹出一个节点（记为cur），打印或者处理cur，如果**弹出节点**有左右子节点，先压右子节点入栈，再压左节点，从栈中弹出节点，循环往复。

  ```java
  public static void preOrderUnRecur(Node head) {
  	System.out.println("preorder traversal");
      if (head != null) {
          Stack<Node> stack = new Stack<>();
          stack.add(head);
          while (!stack.isEmpty()) {
              head = stack.pop();
              System.out.print(head.value + " ");
              if (head.right != null) {
  				stack.push(head.right);
              }
              if (head.left != null) {
                  stack.push(head.left);
              }
          }
      }
      System.out.println();
  }
  ```

- 中序遍历，每棵子树，对于这棵树，左边界全部进栈，弹出节点的过程中打印，对于**弹出节点**的右树重复。

  ```java
  public static void inOrderUnRecur(Node head) {
      System.out.println("inorder traversal");
      if (head != null) {
          Stack<Node> stack = new Stack<>();
          while (!stack.isEmpty() || head != null) {
              if (head != null) {
                  stack.push(head);
                  head = head.left;
              } else {
                  head = stack.pop();
                  System.out.print(head.value + " ");
                  head = head.right;
              }
          }
      }
      System.out.println();
  }
  ```

- 后序遍历，开两个栈，将头节点压入一个操作栈。将操作栈中的数压入收集栈中，当前节点的左节点先压入操作栈，再压右节点，循环操作。头右左 -> 左右头

  ```java
  public static void postOrderUnRecur1(Node head) {
      System.out.println("preorder traversal");
  	if (head != null) {
  		Stack<Node> s1 = new Stack<>();
          Stack<Node> s2 = new Stack<>();
          s1.push(head);
          while (!s1.isEmpty()) {
              head = s1.pop();
              s2.push(head);
              if (head.left != null) {
                  s1.push(head.left);
              }
              if (head.right != null) {
                  s1.push(head.right);
              }
          }
          while (!s2.isEmpty()) {
  			System.out.println(s2.pop().value + " ");
          }
      }
      System.out.println();
  }
  ```


如何直观的打印一颗二叉树

```java
	public static void printTree(Node head) {
		System.out.println("Binary Tree:");
		printInOrder(head, 0, "H", 17);
		System.out.println();
	}

	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len);
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len);
	}

	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}
```

### **宽度优先遍历**

如何完成二叉树的**宽度优先遍历**(常见题目：求一棵二叉树的宽度)，使用队列

```java
public static void breadthFirstTraversal(Node head) {
    if (head == null) {
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    queue.add(head);
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        System.out.println(cur.value);
        if (cur.left != null) {
			queue.add(cur.left);
        }
        if (cur.right != null) {
			queue.add(cur.right);
        }
    }
}

// 求二叉树的最大宽度（不包含 null 值）
public static int maxWidthUseMap(Node head) {
	if (head == null) {
        return  0;
    }
    Queue<Node> queue = new LinkedList<>();
    queue.add(head);
    HashMap<Node, Integer> levelMap = new HashMap<>();
    levelMap.put(head, 1);
    // 当前正在统计的那一层的层数
    int curLevel = 1;
    // 当前层的宽度是多少
    int curLevelNodes = 0;
    int max = Integer.MIN_VALUE;
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        int curNodeLevel = levelMap.get(cur);
        // 判断当前节点是否还在统计的那一层上
        if (curNodeLevel == curLevel) {
            curLevelNodes++;
        } else {
            max = Math.max(max, curLevelNodes);
            curLevel++;
            // 分支进来的时候已经有一个节点在当前统计的那一层上了
            curLevelNodes = 1;
        }
        if (cur.left != null) {
            // 记录下一层子节点的层数
            levelMap.put(cur.left, curNodeLevel + 1);
            queue.add(cur.left);
        }
        if (cur.right != null) {
            levelMap.put(cur.right, curNodeLevel + 1);
            queue.add(cur.right);
        }
    }
    // 与最后一层进行比较
    max = Math.max(max, curLevelNodes);
    return max;
}

public static int maxWidthNoMap(Node head) {
    if (head ==null) {
		return 0;
    }
    Queue<Node> queue = new LinkedList<>();
    queue.add(head);
    // 当前层的节点数
    int curLevelNodes = 0;
    // 当前层最右面的节点
    Node curEnd = head;
    // 下一层最右边的节点
    Node nextEnd = null;
    int max = Integer.MIN_VALUE;
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        if (cur.left != null) {
			queue.add(cur.left);
            nextEnd = cur.left;
        }
        if (cur.right != null) {
            queue.add(cur.right);
            nextEnd = cur.right;
        }
        curLevelNodes++;
        if (cur == curEnd) {
            max = Math.max(max, curLevelNodes);
            curLevelNodes = 0;
            curEnd = nextEnd;
        }
    }
     return max;
}
```

### 搜索二叉树（Binary Search Tree）

它或者是一棵**空树**，或者是具有下列性质的 **二叉树** ： 若它的左子树不空，则左子树上所有结点的值均**小于**它的 根结点 的值； 若它的右子树不空，则右子树上所有结点的值均**大于**它的根结点的值； 它的左、右子树也分别为 二叉排序树，没有值重复的节点。

```java
class Solution {
    public long preVal = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        boolean isLeftBST = isValidBST(root.left);
        if (!isLeftBST) {
            return false;
        }
        if (root.val <= preVal) {
            return false;
        } else {
            preVal = root.val;
        }
        return isValidBST(root.right);
    }
}
```

### 平衡二叉树

1. 可以是空树。
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

```java
public boolean isBalanced(Node head) {
	return height(head) >= 0;
}
public int height(Node head) {
	if (head == null) {
		return 0;
    }
    leftHeight = height(head.left);
    rightHeight = height(head.right);
    // 如果存在一颗子树不平衡，整棵子树不平衡
    if (rightHeight == -1 || leftHeight == -1 || Math.abs(rightHeight - leftHeight) > 1) {
        return -1;
    }
    return Math.max(leftHeight, rightHeight) + 1;
}
```

### 满二叉树

一棵深度为 n 且有 2^n - 1 个结点的二叉树。

```java
// 信息体，一个是高度，一个是节点个数
public static class Info {
    public int height;
    public int nodes;
    
    public Info(int h, int n) {
        height = h;
        nodes = n;
    }
}

public static boolean ifFull(Node head) {
	if (head == null) {
		return true;
    }
    Info data = process(head);
    return data.nodes == (1 << data.height) - 1;
}

public static Info process(Node head) {
    if (head == null) {
		return new Info(0, 0);
    }
    Info leftData = process(head.left);
    Info rightData = process(head.right);
    
    // 加工自己的两个数据
    int height = Math.max(leftData.height, rightData.height) + 1;
    int nodes = leftData.nodes + rightData.nodes + 1;
    
    return new Info(height, nodes);
    
}
```

### 完全二叉树

除了最右边位置上有结点缺少，其他都是丰满的。

判断条件：使用宽度优先遍历。①任一节点有右无左，返回false。②第一个条件成立，第一个没有左右孩子的后面的节点必须是叶节点。

```java
public static boolean isCBT(Node head) {
    if (head == null) {
		return true;
    }
    LinkedList<Node> queue = new LinkedList<>();
    // 是否遇到左右孩子不双全的节点
    boolean leaf = false;
    Node l = null;
    Node r = null;
    queue.add(head);
    while (!queue.isEmpty()) {
		head = queue.poll();
        l = head.left;
        r = head.right;
        // 遇到了左右孩子不全的，判断是不是叶节点
        if ((leaf && (l != null || r != null)) 
           ||
            (l == null && r != null)
           ) {
            return false;
        }
        if (l != null) {
			queue.add(l);
        }
        if (r != null) {
            queue.add(r);
        }
        if (l == null || r == null) {
            leaf = true;
        }
    }
    return true;
}
```

### **最低公共祖先**

```java
public static Node lowestAncestor(Node head, Node o1, Node o2) {
	if (head == null || head == o1 || head == o2) {
		return head;
    }
    Node left = lowestAncestor(head.left, o1, o2);
    Node right = lowestAncestor(head.right, o1, o2);
    // 左右两棵树，遇到 o1 就返回 o1，遇到 o2 就返回 o2
    if (left != null && right != null) {
		return head;
    }
    // 左右两棵树，既没有 o1，也没有 o2，肯定返回空
    return left != null ? left : right;
}
```

#### **后继节点**

中序遍历中后一个节点。

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;
    public Node parent;

    public Node(int data) {
        this.value = data;
    }
}
// 时间复杂度是 O(K) ，K是到后继节点的距离
public static Node getSuccessorNode(Node node) {
    if (node == null) {
        return node;
    }
    if (node.right != null) {
        return getLeftMost(node.right);
    } else { // 无右子树
        Node parent = node.parent;
        // 最右节点也考虑进来了，返回的是null
        while (parent != null && parent.right == node) { // 当前节点是其父亲节点右孩子
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}

public static Node getLeftMost(Node node) {
    if (node == null) {
        return node;
    }
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```

#### **二叉树的序列化与反序列化**

深度优先搜索 

```java
public static String preSerial(Node head) {
    if (head == null) {
		return "#_";
    }
    String res = head.value + "_";
    res += preSerial(head.left);
    res += preSerial(head.right);
    return res;
}

public static Node deserialByPre(String preStr) {
    String[] values = preStr.split("_");
    Queue<String> queue = new LinkedList<>();
    for (int i = 0; i < values.length; i++) {
        queue.add(values[i]);
    }
    return reconPreOrder(queue);
}

public static Node reconPreOrder(Queue<String> queue) {
    String value = queue.poll();
    if (value.equals("#")) {
		return null;
    }
    Node head = new Node(Integer.valueOf(value));
    head.left = reconPreOrder(queue);
    head.right = reconPreOrder(queue);
    return head;
}
```

## 图结构

### 邻接矩阵 邻接表

图的表示有两种：二维数组（邻接矩阵）、链表（邻接表，占用空间少）

```java
// 有向无权图
// 邻接表
// graph[x] 存储 x 的所有邻居节点
List<Integer>[] graph;

// 有向加权图
// 邻接表
// graph[x] 存储 x 的所有邻居节点以及对应的权重
List<int[]>[] graph;

// 邻接矩阵
boolean[][] matrix;

// 邻接矩阵 
// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
int[][] matrix;

// 无向图
// 如果连接无向图中的节点 x 和 y，把 matrix[x][y] 和 matrix[y][x] 都变成 true 不就行了；
// 邻接表也是类似的操作，在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x。
```

 ```java
 // 图的详细表示
 public class Graph {
     public HashMap<Integer, Node> nodes;
     public HashSet<Edge> edges;
     
     public Graph() {
         nodes = new HashMap<>();
         edges = new HashSet<>();
     }
 }
 
 class Node {
     public int value;
     // 进入 node 的边数
     public int in;
     public int out;
     public ArrayList<Node> nexts;
     public ArrayList<Edge> edges;
     
     public Node(int value) {
         this.value = value;
         in = 0;
         out = 0;
         nexts = new Arraylist<>();
         edges = new ArrayList<>();
     }
 }
 
 class Edge {
     public int weight;
     public Node from;
     public Node to;
     
     public Edge(int weight, Node from, Node to) {
         this.weight = weight;
         this.from = from;
         this.to = to;
     }
 }
 ```

### 宽度优先遍历

[797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

- 使用队列实现

```java
class Solution {
    
    // BFS
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> res = new ArrayList<>();
        if (graph == null || graph.length == 0) {
            return res;
        }
        Queue<LinkedList<Integer>> queue = new LinkedList<>();
        LinkedList<Integer> path = new LinkedList<>();
        path.add(0);
        queue.add(path);
        
        while (!queue.isEmpty()) {
            // 取出的是当前层的所有节点
            LinkedList<Integer> cur = queue.poll();
            int curNode = cur.getLast();
            for (int next : graph[curNode]) {
                cur.add(next);
                if (next == graph.length - 1) {
                    res.add(new LinkedList<>(cur));
                } else {
                    queue.offer(new LinkedList<>(cur));
                }
                cur.removeLast();
            }
        }
        return res;
    }
}
```

### 深度优先遍历

- 使用栈实现

```java
class Solution {
    
    // DFS
    private List<List<Integer>> res = new ArrayList<>();
    private LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
		if (graph == null || graph.length == 0) {
            return res;
        }
        dfs(graph, 0);
        return res;
    }
    
    private void dfs(int[][] graph, int node) {
        path.add(node);
        if (node == graph.length - 1) {
            res.add(new LinkedList<>(path));
        }
        for (int next : graph[node]) {
            dfs(graph, next);
            path.removeLast();
        }
    }
}
```

### Kruskal 最小生成树

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220502100115264.png)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220502101011671.png)


#### 261. 以图判树

给定编号从 0 到 n - 1 的 n 个结点。给定一个整数 n 和一个 edges 列表，其中 edges[i] = [ai, bi] 表示图中节点 ai 和 bi 之间存在一条无向边。如果这些边能够形成一个合法有效的树结构，则返回 `true` ，否则返回 `false` 。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220621144507573.png)

```bash
输入: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
输出: true
```

```java
    class Solution {
    // 并查集判断是否是同一个集合来判断是否成环
    public boolean validTree(int n, int[][] edges) {
        UnionFind uf = new UnionFind(n);
        for (int[] edge : edges) {
            int a = edge[0];
            int b = edge[1];
            if (uf.connected(a, b)) {
                return false;
            }
            uf.union(a, b);
        }
        return uf.count() == 1;
    }

    class UnionFind {
        // 连通的数量
        private int count;
        // 连通树的高度
        private int[] rank;
        private int[] root;

        public UnionFind(int size) {
            this.count = size;
            root = new int[size];
            rank = new int[size];
            for (int i= 0; i < size; i++) {
                root[i] = i;
                rank[i] = 1;
            }
        }

        public int find(int x) {
            if (x == root[x]) {
                return x;
            }
            return root[x] = find(root[x]);
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rank[rootX] > rank[rootY]) {
                root[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                root[rootX] = rootY;
            } else {
                root[rootY] = rootX;
                rank[rootX]++;
            }
            count--;
        }

        public boolean connected(int x, int y) {
            return find(x) == find(y);
        }

        public int count() {
            return count;
        }
    }
}
```


#### 1584. 连接所有点的最小费用

[1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

给你一个`points` 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 **曼哈顿距离** ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 `val` 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。

```java
class Solution {
    // 小根堆 + Kruskal + 并查集
    public int minCostConnectPoints(int[][] points) {
        if (points == null || points.length == 0) {
            return 0;
        }
        PriorityQueue<Edge> queue = new PriorityQueue<>((a, b) -> a.weight - b.weight);
        int len = points.length;
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len; j++) {
                int[] pointX = points[i];
                int[] pointY = points[j];
                int weight = Math.abs(pointX[0] - pointY[0]) + Math.abs(pointX[1] - pointY[1]);
                queue.add(new Edge(i, j, weight));
            }
        }
        // kruskal 并查集
        int res = 0;
        int count = len - 1;
        UnionFind uf = new UnionFind(len);
        while (!queue.isEmpty() && count > 0) {
            Edge e = queue.poll();
            if (uf.connected(e.i, e.j)) {
                continue;
            }
            uf.union(e.i, e.j);
            res += e.weight;
            count--;
        }
        return res;
    }

    class Edge {
        private int i;
        private int j;
        private int weight;

        public Edge(int i, int j, int weight) {
            this.i = i;
            this.j = j;
            this.weight = weight;
        } 
    }

    class UnionFind {
        // 连通树的高度
        private int[] rank;
        private int[] root;

        public UnionFind(int size) {
            root = new int[size];
            rank = new int[size];
            for (int i= 0; i < size; i++) {
                root[i] = i;
                rank[i] = 1;
            }
        }

        public int find(int x) {
            if (x == root[x]) {
                return x;
            }
            return root[x] = find(root[x]);
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rank[rootX] > rank[rootY]) {
                root[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                root[rootX] = rootY;
            } else {
                root[rootY] = rootX;
                rank[rootX]++;
            }
        }

        public boolean connected(int x, int y) {
            return find(x) == find(y);
        }
    }
}
```

### Kruskal 算法和 Prim 算法区别

在 Kruskal 算法中，我们通过增加`边数`来扩大「最小生成树」；

在 Prim 算法中，我们通过增加`顶点`来扩大「最小生成树」。

```java
class Solution {
    // Prim 算法
    public int minCostConnectPoints(int[][] points) {
        if (points == null || points.length == 0) {
            return 0;
        }
        PriorityQueue<Edge> queue = new PriorityQueue<>((a, b) -> a.weight - b.weight);
        int len = points.length;
        boolean[] visited = new boolean[len];
        // 将0相关的边加入队列
        for (int j = 1; j < len; j++) {
            int[] p1 = points[0];
            int[] p2 = points[j];
            int weight = Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);
            queue.add(new Edge(0, j, weight));
        }
        visited[0] = true;

        // Prim
        int res = 0;
        int count = len - 1;
        while (!queue.isEmpty() && count > 0) {
            // 取权值最小的
            Edge e = queue.poll();
            int p1 = e.start;
            int p2 = e.end;
            // 没有访问过的
            if (!visited[p2]) {
                visited[p2] = true;
                res += e.weight;
                // 将没有访问过的添加到队列
                for (int i = 0; i < len; i++) {
                    if (!visited[i]) {
                        int weight = Math.abs(points[p2][0] - points[i][0]) + Math.abs(points[p2][1] - points[i][1]);
                        queue.add(new Edge(p2, i, weight));
                    }
                }
                // 找到一个点
                count--;
            }
        }
        return res;
    }

    class Edge {
        private int start;
        private int end;
        private int weight;

        public Edge(int s, int e, int w) {
            this.start = s;
            this.end = e;
            this.weight = w;
        }
    }
}
```

### Dijkstra Ford 最短路径区别

- Dijkstra 算法只能解决【加权有向图】的权重为【非负数】的 【单源最短路径】 问题。

- Ford 算法能解决【加权有向图】中包含权重为【负数】的 【单源最短路径】 问题。

  N 个顶点的正权环图，正常图，两点之间的最短路径最多经过 N - 1 条边。负权环图没有最短路径。

  `dp[k][u]`表示从起点 0 到终点 u 经过 k 条边最短距离为 `dp[k][u]` 

- Bellman-Ford 算法如何检测「负权环」

  「Bellman-Ford 算法」虽然不能检测到「负权环图」的最短路径，但是它能检测到「图」中是否存在「负权环」。

  检测方法： 对所有边进行 N−1 次松弛之后，再进行第 N 次松弛。根据「Bellman-Ford 算法」，所有的边在 N−1 次松弛之后，所有的距离必然是最短距离。如果在进行第 N 次松弛后，对于一条边 edge(u, v)，还存在 distances[u] + weight(u,v) \< distances(v) 的情况，也就是说，还存在更短的路径。此时就能说明「图」中存在「负权环」

    ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220621103649140.png)

- 优化 Ford 算法，每次循环遍历每一条边，对数组进行更新，但是遍历顺序的不同，结果有好有坏，使用基于【队列】优化的 Ford 算法，SPFA 算法（Shortest Path Faster Algorithm）。 

  「SPFA 算法」主要是通过「队列」来维护我们接下来要遍历边的起点，而不是「Bellman Ford」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到「队列」为空，我们就可以终止算法。此时，我们就可以得到「图」中其他顶点到给定顶点的最短距离了。


#### 743. 网络延迟时间

[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // Dijkstra Algorithm
        final int INF = Integer.MAX_VALUE >> 1;
        // 使用邻接矩阵
        int[][] graph = new int[n][n];
        // init
        for (int i = 0; i < n; i++) {
            Arrays.fill(graph[i], INF);
        }
        for (int[] t : times) {
            graph[t[0] - 1][t[1] - 1] = t[2];
        }

        // dist[i] 表示从 k 开始到 i 的最小路径权重
        int[] dist = new int[n];
        Arrays.fill(dist, INF);
        dist[k - 1] = 0;

        // 记录访问到的节点
        boolean[] visited = new boolean[n];

        // 使用小根堆表示到该节点的最小路径权重 int[] {节点序号，权重}
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        queue.offer(new int[] {k - 1, 0});

        while (!queue.isEmpty()) {
            // 当前节点，最短的
            int[] cur = queue.poll();
            int i = cur[0];
            if (visited[i]) {
                continue;
            }
            visited[i] = true;
            // 遍历相邻节点，更新最小路径权重
            for (int j = 0; j < n; j++) {
                // 从开始到当前节点的最小路径权重加上向下一个节点的权重
                int len = dist[i] + graph[i][j];
                // 新的权重小于原来的话就更新
                if (len < dist[j]) {
                    dist[j] = len;
                    queue.offer(new int[] {j, len});
                }
            }
        }
        
        // 所有节点都收到信号，找 dist[] 中的最大值，有 INF 就到不了所有的节点
        int res = 0;
        for (int d : dist) {
            res = Math.max(res, d);
        }
        return res == INF ? -1 : res;
    }
}
```

没有权值为负数的边，改写堆的问题：如果一个节点进入堆中后不需要修改其值，可以使用系统给的堆。如果进入堆中的值需要改变，则得自己实现一个堆。

#### 787. K 站中转内最便宜的航班

[787. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [from~i~, to~i~, price~i~] ，表示该航班都从城市 from~i~ 开始，以价格 price~i~ 抵达  to~i~。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。

```java
class Solution {
    // Ford Algorithm
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
		// 实际也是动态规划问题，数组表示从起点开始，到达 i 的最小权重为 dp[i]
        if (src == dst) {
            return 0;
        }
        int INF = Integer.MAX_VALUE;
        // 记录前一次动态规划的结果
        int[] pre = new int[n];
        int[] cur = new int[n];
        Arrays.fill(pre, INF);
        Arrays.fill(cur, INF);
        pre[src] = 0;
        // 最多经过 k 站，就是最多经过 k + 1 条边
        for (int i = 0; i <= k; i++) {
            cur[src] = 0;
            for (int[] flight : flights) {
                int from = flight[0];
                int to = flight[1];
                int cost = flight[2];
                if (pre[from] < INF) {
                    cur[to] = Math.min(cur[to], pre[from] + cost);
                }
            }
            pre = copyArray(cur);
        }
        return cur[dst] == INF ? -1 : cur[dst];
    }
    
    private int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }
}
```

### 拓扑排序

Topological Order，针对**有向无环图（Directed Acyclic Graph, DAG）**的一种算法，是对图中所有顶点按照先后顺序的一种线性排序。

先将入度为 0 的顶点加入队列，在弹出队列的时候将相关顶点的入度减 1，并将该顶点标记为已访问。循环上面操作，弹出序列的顺序就是拓扑排序的顺序。

#### 207. 课程表

[207. 课程表](https://leetcode.cn/problems/course-schedule/) （环检测、拓扑排序）

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

使用邻接表`List<Integer>[] graph`，graph[i] 存储节点 i 指向的节点。

```java
// 环检测算法 DFS
class Solution {
    // 防止重复遍历同一个节点
    boolean[] visited;
    // 记录当前 traverse 经过的路径
    boolean[] onPath;
    boolean hasCycle;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        
        // 并不是所有节点都相连
        for (int i = 0; i < numCourses; i++) {
            traverse(graph, i);
        }
        return !hasCycle;
    }

    // 从 s 开始 DFS 遍历
    private void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // 存在环
            hasCycle = true;
        }
        if (visited[s] || hasCycle) {
            return;
        }
        // 标记已经遍历
        visited[s] = true;
        // 开始遍历节点 s
        onPath[s] = true;
        for (int node : graph[s]) {
            traverse(graph, node);
        }
        // 节点 s 遍历完成，回溯判断
        onPath[s] = false;
    }

    private List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        LinkedList<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            // 添加一条从 from 到 to 的边
            graph[from].add(to);
        }
        return graph;
    }
}

// BFS
// 使用队列
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 邻接表
        List<Integer>[] graph = new LinkedList[numCourses];
        // 入度
        int[] indegree = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        // 构建入度数组
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            graph[from].add(to);
            indegree[to]++;
        }
        // 使用队列放入度为 0 的节点
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }
        // 记录访问的节点数量
        int count = 0;
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            count++;
            for (int next : graph[cur]) {
                // indegree[node]--;
                if (--indegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }
        return count == numCourses;
    }
}
```

#### 210. 课程表 II

[210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 

将上面环检测 DFS **后续遍历**的结果进行反转就是拓扑排序的结果。

```java
// DFS
class Solution {
    
    boolean[] visited, onPath;
    boolean hasCycle;
    List<Integer> postOrder = new ArrayList<>();
    
    public int[] findOrder(int numCourses, int[][] prerequisites) {
		List<Integer>[] graph = new LinkedList[numCourses];

        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            graph[from].add(to);
        }
        
        for (int i = 0; i < numCourses; i++) {
            traverse(graph, i);
        }
        
        int[] res = new int[numCourses];
        if (hasCycle) {
            return new int[0];
        }
        Collections.reverse(postOrder);
        for (int i = 0; i < numCourses; i++) {
            res[i] = postOrder.get(i);
        }
        return res;
    }
    
    private void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            hasCycle = true;
        }
        if (visited[s] || hasCycle) {
            return;
        }
        visited[s] = true;
        onPath[s] = true;
        for (int node : graph[s]) {
            traverse(graph, node);
        }
        postOrder.add(s);
        onPath[s] = false;
    }
}

// BFS
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // BFS 使用队列 邻接表表示有向图
        List<Integer>[] graph = new LinkedList[numCourses];
        int[] indegree = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            graph[from].add(to);
            indegree[to]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }
        int count = 0;
        int[] res = new int[numCourses];
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            res[count++] = cur;
            for (int next : graph[cur]) {
                if (--indegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }
        return count == numCourses ? res : new int[0];
    }
}
```



## 滑动窗口

`滑动窗口`，就是有一个大小可变的窗口，左右两端方向一致的向前滑动（右端固定，左端滑动；左端固定，右端滑动），左端不能超过右端。一般是要求最值（最大长度，最短长度等等）或者子序列

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/SlidingWindow.jpg)

## 单调栈

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/monotonousStack.jpg)

## 单调队列

```java
// 滑动窗口最大值
// 递减单调队列，没有必要维护窗口中的所有元素
class MonotonicQueue {
    Deque<Integer> deque = new LinkedList<>();
    
    /**
    添加元素时，如果要添加的元素大于入口处(队列尾部)的元素，就将入口元素弹出，直到小于等于队列入口的元素为止
    保证队列元素单调递减
    */
    public void offer(int val) {
        while (!deque.isEmpty() && val > deque.peekLast()) {
            deque.pollLast();
        }
        deque.offerLast(val);
    }
    
    /**
    弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等就弹出，不相等不做任何操作
    看窗口的第一个元素是不是最大的
    */
    public void poll(int val) {
        if (!deque.isEmpty() && val == deque.peekFirst()) {
            deque.pollFirst();
        }
    }
    
    public int peek() {
        return deque.peekFirst();
    }
}

class Solution {
    public int[] maxSlidingWindow(int[] nums int k) {
        if (nums.length == 0) {
            return new int[0];
        }
        int index = 0, len = nums.length;
        int[] res = new int[len - k + 1];
        MonotonicQueue window = new MonotonicQueue();
        for (int i = 0; i < k; i++) {
            window.offer(nums[i]);
        }
        res[index++] = window.peek();
        for (int i = k; i < len; i++) {
            window.poll(num[i - k]);
            window.offer(num[i]);
            res[index++] = window.peek();
        }
        return res;
    }
}
```

## 前缀树

前缀树是 N 叉树的一种特殊形式，用来存储字符串。根节点的 pass 值代表加入了多少字符串。

```java
class TrieNode {
    // 有多少字符串经过
	private int pass;
    // 该字符串有多少个
    private int end;
    private TrieNode[] nexts;
    
    public TrieNode() {
		this.pass = 0;
        this.end = 0;
        nexts = new TrieNode[26];
    }
}
```

![](https://img2018.cnblogs.com/blog/1519578/201907/1519578-20190724132134884-1903210243.png)

## 并查集

- 父节点：顶点的直接父亲节点

- 根节点：没有父节点的节点

判断集合是否是同一个，连通性的问题，合并集合。判断集合的顶部是否相同，少的顶部指向多的顶部。

并查集的瓶颈，一个链过长，需要在向上找父节点的同时将分支节点指向顶部的节点。

```java
class UnionFind {
    private int[] root;
    // 秩 树的高度
    private int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }
    public int find(int x) {
//        while (x != root[x]) {
//            x = root[x];
//        }
//        return x;
        // 路径压缩，优化find的时间复杂度
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            // 高度小的树连到高度大的树上面去
            if (rank[rootX] > rank[rootY]) {
                root[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                root[rootX] = rootY;
            } else {
                root[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
```

```java
import java.util.HashMap;
import java.util.List;
import java.util.Stack;

public class UnionFind {
    /**
     * 样本进来会包一层，叫做元素
     * @param <V> 样本
     */
    public static class Element<V> {
        public V value;

        public Element(V value) {
            this.value = value;
        }
    }

    public static class UnionFindSet<V> {
        // 样本与元素之间一一对应
        public HashMap<V, Element<V>> elementMap;
        // key 元素的上一个父节点 value
        public HashMap<Element<V>, Element<V>> fatherMap;
        // 某个集合的代表元素 key，记录该集合的大小 value，即集合的元素个数
        public HashMap<Element<V>, Integer> sizeMap;

        /**
         * @param list 给定样本的初始化
         */
        public UnionFindSet(List<V> list) {
            elementMap = new HashMap<>();
            fatherMap = new HashMap<>();
            sizeMap = new HashMap<>();
            for (V value : list) {
                // 将样本包成元素
                Element<V> element = new Element<V>(value);
                elementMap.put(value, element);
                fatherMap.put(element, element);
                sizeMap.put(element, 1);
            }
        }

        /**
         * @param a 集合 a
         * @param b 集合 b
         * @return 是否是同一个集合
         */
        public boolean isSameSet(V a, V b) {
            // 前提是已经经过初始化
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
            }
            return false;
        }

        /**
         * @param element 单个元素
         * @return 集合中的最顶上的元素，代表元素
         */
        private Element<V> findHead(Element<V> element) {
            Stack<Element<V>> path = new Stack<>();
            while (element != fatherMap.get(element)) {
                path.push(element);
                // 一直向上走
                element = fatherMap.get(element);
            }
            // 将链变成扁平的进行优化
            while (!path.isEmpty()) {
                // 将栈中的元素直接指向大顶部
                fatherMap.put(path.pop(), element);
            }
            return element;
        }

        /**
         * @param a 集合 a
         * @param b 集合 b
         */
        public void union(V a, V b) {
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                Element<V> aHead = findHead(elementMap.get(a));
                Element<V> bHead = findHead(elementMap.get(b));
                if (aHead != bHead) {
                    // 数量较少的集合挂在数量较多的集合的顶端底下
                    Element<V> big = sizeMap.get(aHead) >= sizeMap.get(bHead) ? aHead : bHead;
                    Element<V> small = big == aHead ? bHead : aHead;
                    // 将 small 挂在 big 上
                    fatherMap.put(small, big);
                    sizeMap.put(big, sizeMap.get(aHead) + sizeMap.get(bHead));
                    sizeMap.remove(small);
                }
            }
        }
    }
}
```

## 有序表

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1204/image-20220106165446011.png)

红黑树，AVL，SBT、跳表所实现的有序表查找，插入时间复杂度是一样的 O(logN)。

### AVL

当插入或者删除一个节点时，可能会让整棵 AVL 树不平衡。此时，只需要把最小不平衡子树调整，即可恢复整体的平衡性。增加和删除元素的操作则可能需要借由一次或多次**树旋转**，以实现树的重新平衡。

LL 右旋

![img](https://pic4.zhimg.com/v2-373766641d1c03a78f3d7eac803d1f57_b.webp)

RR 左旋

![img](https://pic1.zhimg.com/v2-e7044e4965ba640ee9ef35beac407cdc_b.webp)

LR 先左旋再右旋

![img](https://pic4.zhimg.com/80/v2-f95f74ae3e76458d56ae3208bdde5987_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-e60c01fa31634d9c63c63ecfb58036b2_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-37639b80cb65b60a531d3f5dc73dad52_720w.jpg)

RL 先右旋再左旋

![img](https://pic2.zhimg.com/80/v2-41a3bdcb0c8b6478446c09ce22d14561_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-185889845a6451419f0dcaf171b70be4_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-da91941e1e9eca7ad2e174c752920274_720w.jpg)

### SBT

Size Balanced Tree，**每棵树的大小不小于其兄弟树的子树的大小**。

### 红黑树

自平衡的二叉查找树，不像 AVL 树保持绝对的平衡。 

- 节点只能是红色或者黑色。
- 根节点是黑色。
- 红色节点的子节点都是黑的，即红色节点不能连续。
- 每个叶子节点都是黑色的 null 节点。
- 从任一节点到其每个叶节点的所有路径上有相同的**黑节点**。该性质确保从根节点到叶子的最长路径不会超过最短路径的2倍。

