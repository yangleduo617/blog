# Chapter14

## 泛型

### 泛型的好处

1. 编译时，检查添加元素的类型，提高了安全性。

2. 减少了类型转换的次数，提高了效率。

   - `ArrayList`不使用泛型时，先向上转型为`Object`，在取出时，还需要转换成相应的类型才能调用方法。

## 自定义泛型

### 自定义泛型类

1. 类的 后面加`泛型`，所以我们把该类 就称为自定义泛型类

   ```java
   class Tiger<T, R, M> {}
   ```

2. T, R, M 泛型的标识符, 一般是单个大写字母

3. 泛型标识符可以有多个

4. `普通成员`可以使用泛型(属性、方法)

5. 使用泛型的`数组`，不能初始化

   ```java
   // 因为数组在new 不能确定T 的类型，就无法在内存开空间
   T[] t = new T[10];// wrong 
   ```

6. `静态方法、属性`中不能使用类的泛型，因为静态是和类相关的，在类加载时，对象还没有创建。所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化。

### 自定义泛型接口

```java
interface 接口名<T, R...> {}
```

1. 接口中，静态成员不能用`泛型`

2. 泛型接口的类型在`继承`接口或者`实现`接口时确定

3. 没有指定类型，默认为`Object` 

### 自定义泛型方法

```java
访问修饰符 <T, R...> 返回类型 方法名(参数列表) {}
```

1. 泛型方法，可以定义在普通类中, 也可以定义在泛型类中

2. 当调用方法时，传入参数，编译器就会确定类型

3. `public void eat(E e) {}`，该方法只是使用了泛型，但不是泛型方法，可以使用`类声明`的泛型，也可以使用`自己声明`的泛型

## 通配符

1. 泛型不具备继承

   ```java
   // 泛型没有继承性
   List<Object> list = new ArrayList<String>(); // wrong
   ```

2. <?> 支持任意泛型类型

3. `<? extends A>`：支持A类以及A类的子类，规定了泛型的**上限**

4. `<? super A>`：支持A类以及A类的父类（不限于直接父类），规定了泛型的**下限**